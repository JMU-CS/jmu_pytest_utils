"""Build and test Gradescope autograder.zip files."""

import importlib
import os
import shutil
import sys
import zipfile

# Path and names of the template files
TEMPLATE_PATH = os.path.join(os.path.dirname(__file__), "template")
CONFIG_FILES = ["docstring.cfg", "flake8.cfg", "requirements.txt"]
SCRIPT_FILES = ["setup.sh", "run_autograder"]

# Files and dirs created by run_autograder
OUTPUT_FILES = ["NAME.txt", "OUTPUT.txt", "results.json",
                "coverage.json", ".coverage"]
CACHE_DIRS = ["__pycache__", ".pytest_cache"]

# Name of zip generated by the build command
ZIP_FILENAME = f"autograder_{os.path.basename(os.getcwd())}.zip"


def init_cfg():
    """Initialize global variables with default values."""
    global SUBMISSION_FILES, AUTOGRADER_TESTS, ADDITIONAL_FILES
    global SUBMISSION_LIMIT, FUNCTION_TIMEOUT, SCHOOL_TIME_ZONE, INSTALL_PYTHON_V

    SUBMISSION_FILES = []
    AUTOGRADER_TESTS = []
    ADDITIONAL_FILES = []
    SUBMISSION_LIMIT = os.getenv("SUBMISSION_LIMIT", -1)
    FUNCTION_TIMEOUT = os.getenv("FUNCTION_TIMEOUT", 5)
    SCHOOL_TIME_ZONE = os.getenv("SCHOOL_TIME_ZONE", "US/Eastern")
    INSTALL_PYTHON_V = os.getenv("INSTALL_PYTHON_V", 3.12)


def copy_file(filename, overwrite=False):
    """Copy a template file if not already exists.

    Args:
        filename (str): Name of the file to copy.
        overwrite (bool): Replace file if exists.
    """
    if overwrite or not os.path.exists(filename):
        print("Copying", filename)
        src = os.path.join(TEMPLATE_PATH, filename)
        shutil.copy(src, ".")


def delete_file(filename, message):
    """Delete a file if the file exists.

    Args:
        filename (str): Path of the file to delete.
        message (str): Additional details to display.
    """
    if os.path.exists(filename):
        print("Deleting", message, filename)
        os.remove(filename)


def load_cfg():
    """Initialize global variables from config.sh file."""

    # Update global variables if set by config.sh
    init_cfg()
    print("Loading config.sh")
    with open("config.sh") as file:
        for line in file:
            if line.startswith("export"):
                name, value = line[7:].rstrip().split("=")
                value = value[1:-1]  # remove quotes
                if name.endswith("FILES") or name.endswith("TESTS"):
                    value = value.replace("/", os.path.sep)
                    value = value.split()  # space delimited
                globals()[name] = value


def make_cfg():
    """Generate config.sh file based on existing files."""
    global SUBMISSION_FILES, AUTOGRADER_TESTS, ADDITIONAL_FILES

    # Files to ignore during os.walk()
    ignore = ["config.sh", "config.bak"] + CONFIG_FILES + SCRIPT_FILES + \
        OUTPUT_FILES + [ZIP_FILENAME]

    # Discover files in the current path
    main_files = []
    test_files = []
    data_files = []
    for root, _, files in os.walk("."):
        if os.path.basename(root) in CACHE_DIRS:
            continue
        for file in sorted(files):
            if file not in ignore:
                file_path = os.path.join(root, file)[2:]  # remove "./"
                if file.endswith(".py"):
                    if file.startswith("test_") or os.path.basename(root) == "tests":
                        test_files.append(file_path)
                    else:
                        main_files.append(file_path)
                else:
                    data_files.append(file_path)

    # Update global variables if set by tests
    init_cfg()
    for filename in test_files:
        module_name = filename[:-3].replace(os.path.sep, ".")
        module = importlib.import_module(module_name)
        for name in ["SUBMISSION_FILES", "AUTOGRADER_TESTS", "ADDITIONAL_FILES",
                     "SUBMISSION_LIMIT", "FUNCTION_TIMEOUT", "SCHOOL_TIME_ZONE"]:
            if hasattr(module, name):
                globals()[name] = getattr(module, name)

    # Use discovered files if not set by tests
    if not SUBMISSION_FILES:
        SUBMISSION_FILES = main_files
    if not AUTOGRADER_TESTS:
        AUTOGRADER_TESTS = [file for file in test_files
                            if file not in SUBMISSION_FILES]
    if not ADDITIONAL_FILES:
        ADDITIONAL_FILES = [file for file in main_files + data_files
                            if file not in SUBMISSION_FILES]
    # Special case: don't submit provided files
    SUBMISSION_FILES = [file for file in SUBMISSION_FILES
                        if file not in ADDITIONAL_FILES]

    # Show output if not comparing with backup
    if not os.path.exists("config.bak"):
        print("Creating config.sh")
    src = os.path.join(TEMPLATE_PATH, "config.sh")
    shutil.copy(src, ".")

    # Set variable values in config.sh template
    with open("config.sh") as file:
        text = file.read()
    text = text.format(
        # Use posix path separators for config.sh
        " ".join(SUBMISSION_FILES).replace("\\", "/"),
        " ".join(AUTOGRADER_TESTS).replace("\\", "/"),
        " ".join(ADDITIONAL_FILES).replace("\\", "/"),
        SUBMISSION_LIMIT,
        FUNCTION_TIMEOUT,
        SCHOOL_TIME_ZONE,
        INSTALL_PYTHON_V,
    )
    with open("config.sh", "w") as file:
        file.write(text)


def build_cmd(setup=False):
    """Read config.sh and copy other template files.

    Args:
        setup (bool): Whether to copy the CONFIG_FILES.
    """

    # Generate if needed and load configuration
    if os.path.exists("config.sh"):
        load_cfg()
    else:
        make_cfg()

    # Display resulting environment variables
    print("  SUBMISSION_FILES =", SUBMISSION_FILES)
    print("  AUTOGRADER_TESTS =", AUTOGRADER_TESTS)
    print("  ADDITIONAL_FILES =", ADDITIONAL_FILES)
    print("  SUBMISSION_LIMIT =", SUBMISSION_LIMIT)
    print("  FUNCTION_TIMEOUT =", FUNCTION_TIMEOUT)
    print("  SCHOOL_TIME_ZONE =", SCHOOL_TIME_ZONE)
    print("  INSTALL_PYTHON_V =", INSTALL_PYTHON_V)

    # Count the total number of autograder points
    points = 0
    for filename in AUTOGRADER_TESTS:
        module_name = filename[:-3].replace(os.path.sep, ".")
        module = importlib.import_module(module_name)
        for name in dir(module):
            if name.startswith("test_"):
                function = getattr(module, name)
                points += getattr(function, "weight", 0)
    print(f"\033[1;34mAutograder Points: {points}\033[0m")

    # Copy template files if not already exist
    if setup:
        for filename in CONFIG_FILES:
            copy_file(filename)
    for filename in SCRIPT_FILES:
        copy_file(filename)


def debug_cmd():
    """Run the autograder and display the results."""

    print("Running autograder")
    os.system("bash run_autograder")

    print("Opening results.json")
    if os.name == "posix":
        os.system("xdg-open results.json")
    else:
        os.system("start results.json")


def make_zip():
    """Create the autograder zip file for Gradescope."""

    # Files to include in the zip archive
    include = ["config.sh"] + CONFIG_FILES + SCRIPT_FILES + \
        AUTOGRADER_TESTS + ADDITIONAL_FILES

    # Create zip archive; skip unneeded files
    print("Creating", ZIP_FILENAME)
    with zipfile.ZipFile(ZIP_FILENAME, "w", zipfile.ZIP_DEFLATED) as zf:
        for file_path in include:
            if os.path.exists(file_path):
                print("  Adding", file_path)
                zf.write(file_path, file_path)


def files_match(path1, path2):
    """Check if two files have the same contents.

    Args:
        path1 (str): Path to 1st file (Ex: modified).
        path2 (str): Path to 2nd file (Ex: template).

    Returns:
        bool: True if the files have the same contents.
    """
    with open(path1) as file1, open(path2) as file2:
        return file1.read() == file2.read()


def clean_cmd():
    """Run the clean command to remove build files."""

    # Delete config if same as auto generated
    if os.path.exists("config.sh"):
        shutil.move("config.sh", "config.bak")
        make_cfg()
        if files_match("config.sh", "config.bak"):
            delete_file("config.sh", "auto generated")
            os.remove("config.bak")  # No output
        else:
            shutil.move("config.bak", "config.sh")

    # Delete files generated by run_autograder
    for filename in OUTPUT_FILES:
        delete_file(filename, "previous run's")
    for dirname in CACHE_DIRS:
        shutil.rmtree(dirname, True)

    # Delete template files (if not modified)
    for filename in CONFIG_FILES + SCRIPT_FILES:
        if os.path.exists(filename):
            template = os.path.join(TEMPLATE_PATH, filename)
            if files_match(filename, template):
                delete_file(filename, "unmodified")


USAGE = """
Usage: jmu_pytest_utils <command>

Possible commands:
- build: Create zip file for Gradescope
- clean: Delete autograder-related files
- setup: Copy autograder template files
- debug: Run autograder and open results

Usually "jmu_pytest_utils build" is sufficient. If you would like to modify the
autograder scripts or do additional testing, run the "setup" command to copy the
template files. You can then execute run_autograder (manually) to see what will
happen on Gradescope. The "debug" command sets up and runs the autograder, and
opens results.json in the default editor for inspection. The "build" and "clean"
commands will not automatically overwrite or delete any template files that have
been modified during "setup" or "debug" commands.
"""


def main():
    """Parse and run the command-line argument."""
    sys.path.insert(0, os.getcwd())  # for importlib
    command = sys.argv[1] if len(sys.argv) == 2 else None
    match command:
        case "build":
            build_cmd()
            make_zip()
            clean_cmd()
        case "clean":
            clean_cmd()
        case "setup":
            build_cmd(True)
        case "debug":
            build_cmd(True)
            debug_cmd()
        case _:
            print(USAGE)


if __name__ == "__main__":
    main()
